## CORS

-   https://israynotarray.com/nuxt/20230808/2129825058/
-   https://stackoverflow.com/questions/76198151/nuxt-3-how-to-implement-cors

## tensorflowjs 的模型

-   https://www.tensorflow.org/js?hl=zh-tw

## tensorflowjs mobilenet (圖片分類)

-   https://www.npmjs.com/package/@tensorflow-models/mobilenet

## tesnorflowjs coco-ssd (物件偵測)

-   https://github.com/tensorflow/tfjs-models/tree/master/coco-ssd
-   DEMO: https://tensorflow-js-object-detection.glitch.me/

## tensorflowjs image api

-   https://js.tensorflow.org/api/latest/?hl=zh-cn#Operations-Images

## 模型比較

| 模型      | 差異                                                                                                                            | 應用情境                                           | 專案構想                                                                                                                                           |
| --------- | ------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------- |
| MobileNet | MobileNet 是一種用於**圖像分類**的模型。它可以將圖像分類為 ImageNet 資料庫中的標籤。例如，它可以告訴你一張圖像是狗、貓還是車。  | 圖像分類，例如辨識圖片中的物體                     | **智能圖像分類器**：使用 MobileNet 模型來對上傳的圖像進行分類，並結合 Nuxt3 的 UI 來顯示分類結果和相關資訊。                                       |
| Coco SSD  | Coco SSD 是一種**物件偵測**模型。它可以在單一影像中定位及辨識多個物件。例如，它可以告訴你圖像中有什麼物體，並且這些物體在哪裡。 | 物件偵測，例如在圖片中找出並標記物體的位置         | **實時物件追蹤系統**：使用 Coco SSD 模型來偵測和追蹤實時影像中的物件。這個系統可以應用在各種場景，例如監控攝影機、自駕車、或者是機器人視覺系統。   |
| DeepLab   | DeepLab 是一種用於**語意區隔**的模型。它可以將圖像中的每個像素分類到預定義的類別，例如人、汽車、樹等。                          | 語意區隔，例如將圖片中的每個像素分類到預定義的類別 | **智能圖像編輯器**：使用 DeepLab 模型來進行語意區隔，並結合 Nuxt3 的 UI 來讓使用者可以對圖像中的特定類別進行編輯，例如改變背景顏色或者是應用特效。 |

## Server 載入模型或是 Client 載入模型

| 比較維度     | 服務器端加載模型                                                                           | 客戶端加載模型                                                                                           |
| ------------ | ------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------- |
| **優點**     | - 性能和穩定性較高<br>- 兼容性好，不需擔心客戶端設備差異<br>- 有助於保護商業秘密和用戶數據 | - 提供即時反饋，減少網絡延遲<br>- 減輕服務器負擔<br>- 支持離線功能                                       |
| **缺點**     | - 可能增加延遲<br>- 運營成本較高<br>- 大量並發請求可能需更多服務器資源                     | - 受限於客戶端設備的計算能力和存儲空間<br>- 可能存在兼容性和性能問題<br>- 模型直接暴露給用戶，有泄露風險 |
| **適用情況** | - 模型較大，計算複雜<br>- 需要保護模型不被用戶直接訪問                                     | - 模型較小，對即時反饋要求高<br>- 用戶設備相對現代                                                       |

## useState、ref、reactive 的比較

| 功能     | useState                                                                                                   | ref                                                                    | reactive                                                                    |
| -------- | ---------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------- | --------------------------------------------------------------------------- |
| 定義     | `useState` 是 Nuxt3 提供的一個組合式函數，主要用於創建跨組件的並且對 SSR（伺服器端渲染）友好的響應式狀態。 | `ref` 是 Vue3 提供的一個函數，用於創建一個響應式參考值。               | `reactive` 是 Vue3 提供的一個函數，用於創建一個響應式物件。                 |
| SSR      | `useState` 的值會在伺服器端渲染後被保留，並且在客戶端的所有組件中共享。                                    | `ref` 在 SSR 中可能會導致前後端的初始值不一致。                        | `reactive` 在 SSR 中可能會導致前後端的初始值不一致。                        |
| 值類型   | 可以是任何類型。                                                                                           | 可以是任何類型。                                                       | 必須是物件。                                                                |
| 重新渲染 | `useState` 的值會在伺服器端渲染後被保留，並且在客戶端的所有組件中共享。                                    | `ref` 的值在伺服器端渲染後會被丟棄，並且在客戶端的所有組件中重新生成。 | `reactive` 的值在伺服器端渲染後會被丟棄，並且在客戶端的所有組件中重新生成。 |
| 狀態更新 | 使用 `useState` 的值來更新狀態。                                                                           | 使用 `.value` 來更新狀態。                                             | 直接更新物件的屬性。                                                        |
